% \VignetteIndexEntry{widgetTools Introduction}
% \VignetteDepends{widgetTools}
% \VignettePackage{widgetTools}
\documentclass[12pt]{article}
\usepackage{hyperref}
\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in


\begin{document}
\author{Jianhua Zhang}

\title{Building a widget using widgetTools}

\maketitle

\copyright{2002 Bioconductor}

\begin{verbatim}
$Id: widgetTools.Rnw,v 1.4 2002/12/05 14:07:04 jhnzhang Exp $
\end{verbatim}

\tableofcontents

\section{Introduction}

The purpose of widgetTools is to provide the functionalities to allow
users to build funcitonal simple widget. The underlying implementation
of the widget is done by using the R tcltk package but users of
widgetTools do not have to know tcltk command except for some
knowledge of basic geometric management for packing the elements of a
widget.

The design of widgetTools follows the Model-View-Controller pattern
with \em{pWidget} objects as the model, a \em{tkWidget}(s) as the
view, and a \em{updater} as the controller. The interactions between
the model and view follows an observer pattern with a object called
notifier acting as a mediator. Similarly, the interaction between the
view and model also follows a observer pattern with the controller
(\em{updater}) itself acting as a mediator.

Detailed description of \em{pWidget} can be found in
\em{widgetPlans.tex} in the \em{doc} subdirectory of widgetTools and
documantations regarding Model-View-Controller, observer, and mediator
patterns should be available in most designe pattern books. \em{Design
  Patterns} by Gamma et. al. (1997) would be one of them.

\section{Builde a widget}

The first step in building a widget is to crate a tcltk window object
(of tkWidget class) to hold the widget elements (of pWidget class) we
are going to put on (note that a checking was put in to avoid running
the code other than an active consol), a notifier object (of notifer
class) that will be acting as a mediator to manage updating values
displyed in the tcltk window, and an updater object (of updater class)
that will be acting as a controller.

<<>>=
library(widgetTools)
if(interactive()){
    aWidget <- tkWidget(title = "A Test Widget")
    notifier <- notifier()
    updater <- updater()
}
@

A tkWidget object can hold one to many pWidget objects, which contains
methods and variables described below:

\begin{verbatim}

             |-----------------------|
             |        pWidget        |
             |-----------------------|
             | attach(view, observer)|
             | detach(view, observer)|
             | update(value)         |
             |                       |
             | name: string          |
             | parent: string        |
             | type: string          |
             | test: string          |
             | variable: string      |
             | width: integer        |
             | height: integer       |
             | vSCroll: boolean      |
             | hscroll: boolean      |
             | observer: vector      |
             | preFun: function      |
             | postFun: function     |
             |-----------------------|

\end{verbatim}

Where

\begin{itermize}

\item name - the name associated with a given pWidget;
\item type - type of a tk widget (e. g. "text" for text box, "list"
  for list box, ...;
\item parent - the window or frame ... where a given pWidget resides;
\item text - the text feature of a pWidget whose role varies depending
  on the type of widget. If pWidget is a text box, text will be shown
  in the text box rendered. If pWidget is a button, text will be the
  letters that appear on the rendered clikable button ...;
\item variable - a variable that will be associated with the given
  pWidget. Most useable for radio buttons or select boxes;
\item width - the physical width of the pWidget to be
  rendered. Applicable to certain pWidgets;
\item height - the physical height of the pWidget to be rendered;
\item vSCroll - set to be TRUE if the pWidget will have a vertical
  scroll bar;
\item hScroll - set to be TRUE if the pWidget will habe a horizontal
  scroll bar;
\item funs - functions that will be associated with the given pWidget
  and invoked when a given operation to the pWidget takes place
  (e. g. clicked, get focused ...);
\item preFun - the function defining the operations to be performed on
  the text of the pWidget before rendering the text;
\item postFun - the function defining the operations to be performed
  on the text of the pWdiget upon existing;

\end{itemize}

pWidgets may be placed on a tkWidget directly or placed as groups of
pWidgets for better presentation. In the latter case, grouped pWidgets
will have to be placed in different frames and the frames are than
placed on to a tkWidget object. Suppose we would like to create a
widget that has a label ("File Name"), an entry box for inputing file
name, and button for browsing files in one row. Below that row, we
want to have a list box in one row, two radio buttons in another row,
and two select boxes in yet another row. To do that we will need to
have four frames for widget elements in each of the four row. Each
frame has the tkWidget object we created previously as the
parent. Note that a frame can also be the parent of other frames and
so on depending on the level of nesting one would like to have. When we
have the frames ready, we can create the widget elements with their
parents being the frames they belong to. The following code creates
the three widget elements in the first row.

<<>>=
frame1 <- createFrame(aWidget)
aLabel <- pWidget(name = "aLabel", type = "label", parent = "frame1",
text = "File Name: ", width = 0)
anEntry <- pWidget(name = "anEntry", type = "entry", parent =
                   "frame1", width = 50, text = "")
aButton <- pWidget(name = "aButton", type = "button", parent =
                   "frame1", text = "Browse", width = 12,  funs =
                   list(sclick = function(){temp <- fileBrowser();
                                   updatePWidget(updater, getName(aButton),
                                   temp)}))
@

The \em{name} variable of each pWidget object should always been
assinged the same character string as the name of the pWidget object
(e.g. "aButton" for pWidget object \em{aButton}). Variable funs of
each pWidget should be a list of functions defining what to do when
the event associated with the function occurs. For example, the
function for variable funs of \em{aButton} defines that when a single
click on \em{aButton} occurs, function fileBrowser will be called and
returned value will be passed to updatePWidget to update the value of
pWidget \em{aButton}. pWidget objects have set and get functions to
access and modify the variables. For example, we can get and set the
value for the type of a pWidget:

<<>> =
getName(aLabel)
aLabel <- setName(aLabel, "YYY")
getName(aLabel)
aLabel <- setName(aLabel, "aLabel")
@

Now we have three objects of the class pWidget with instructions on how
the corresponding tcltk widget element should be constructed. The
follow convert the three objects into tcltk widget elements based on
the definations and then put the tcltk elements in the frame they belong to.

<<>>=
if(interactive()){
    aLabel <- createPWidget(aLabel, frame1)
    anEntry <- createPWidget(anEntry, frame1)
    aButton <- createPWidget(aButton, frame1)
    doPack(getWinid(aLabel), "left")
    doPack(getWinid(anEntry), "left")
    doPack(getWinid(aButton), "left")
    doPack(frame1, "top")
}
@

When a pWidget is created and the corresponding tcltk widget element
is put in place, a "tkwin" object representing the tcltk widget
element is stored as the winid of the pWidget. Variable winid can be
used later to access the tcltk widget object on the interface.

Now we have a simple interface that does something. If we click the
browse button and select a file name from the browser, the value of
\em{aButton} will be assigned the full path to the file we just
selected as instructed by the function we put as the funs variable of
\em{aButton}.

<<>>=
getValue(aButton)
@

However, what we really want is also to have the file name shown in
the entry box for file name on the interface. To do so, we need to
register \em{anEntry} as an observer of \em{aBuuton} so that each time
when the value of \em{aButton} changes the entry box corresponding to
\em{anEntry} will be notified to make the corresponding changes.

<<>>=
notifier <- register(notifier, getName(aButton), anEntry)
getSubNObse(notifier)
@

Now, when we click the browse button and select a file again, the selected
file will be shown in the entry box and the value of the pWidget
corresponding to the entry box will be updated as well.

<<>>=
getValue(anEntry)
@

Now, we continue to build the list box we want and put it below the
first we just built.

<<>> =
frame2 <- createFrame(aWidget)
aList <- pWidget(name = "aList", type = "list", parent = "frame2",
text = "I am in the second row", width = 50, height = 20, vScroll = TRUE,
hScroll = TRUE)
aList <- createPWidget(aList, frame2)
doPack(frame2, "top")
@

A few more variables need to be defined to build radio buttons. One is
the varaible, which is required to be a tclVar object. Radio buttons
in the same group (only one of which can be selected) should have the
same value for their variables. Another is \em(value} that defines who
is the defult (value = 1).

<<>>=
frame3 <- createFrame(aWidget)
radVar <- tclVar(1)
radio1 <- pWidget(name = "radio1", type = "radio", parent = "frame3", text = "Selecte Me",
value = 1, variable = radVar)
radio2 <- pWidget(name = "radio2", type = "radio", parent = "frame3", text = "How ABout Me",
value = 2, variable = radVar)
radio1 <- createPWidget(radio1, frame3)
radio2 <- createPWidget(radio2, frame3)
doPack(getWinid(radio1), "left")
doPack(getWinid(radio2), "left")
doPack(frame3, "top")
@

\end{document}



























