% \VignetteIndexEntry{widgetTools Introduction}
% \VignetteDepends{widgetTools}
% \VignettePackage{widgetTools}
\documentclass[12pt]{article}
\usepackage{hyperref}
\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in


\begin{document}
\author{Jianhua Zhang}

\title{Building a widget using widgetTools}

\maketitle

\copyright{2002 Bioconductor}

\begin{verbatim}
$Id: widgetTools.Rnw,v 1.9 2002/12/12 22:06:48 jhnzhang Exp $
\end{verbatim}

\tableofcontents

\section{Introduction}

The purpose of widgetTools is to provide the functionalities to allow
users to build a simple widget that contains functional widget
elements. The underlying implementation  of the widget is done by
using the R tcltk package but users of widgetTools do not have to know
tcltk command except for some knowledge of basic geometric management
for packing the elements of a widget.

The design of widgetTools follows the Model-View-Controller pattern
with \em{pWidget} objects being the application data, each of which contains
definitions for a widget element that is going to be rendered, a
\em{widget} object that contains a list of \em{pWidget}s that will be
rendered, and a \em{tkWidget}(s) that provides the interface to hold the
widget elements. \em{pWidget} is the model, tkWidget is the view, and
widget is the controller component of the MVC pattern.

Detailed description of \em{pWidget} can be found in
\em{widgetPlans.tex} in the \em{doc} subdirectory of widgetTools and
documantations regarding Model-View-Controller patterns should be
available in most designe pattern books.

The system is designed in such a way that users only have to deal with
\em{pWidget} and \em{widget} objects. \em{tkWidget} will be managed by
\em{widget}.

\section{Build a widget}

The first step involved in building a widget is to crate a list of
\em{pWidgets} that defines the widget elements that are going to be
rendered. A pWidget is an object of either the basicPW or a subclass
of basicPW. basicPW and all the subclasses are S4 classes.

\begin{verbatim}

             |-----------------------|
             |        basicPW        |
             |-----------------------|
             | name: string          |
             | value: string         |
             | type: string          |
             | width: string         |
             | funs: list            |
             | preFun: function      |
             | postFun: function     |
             | notify: function      |
             |-----------------------|

\end{verbatim}

Where

\begin{itemize}

\item name - a character string for the name to be associated with a
  given pWidget;
\item type - type of a tk widget (e. g. "text" for text box, "list"
  for list box, ...;
\item value: a character string used to strore information that will
  be displayed on the interface or updated using values obtained from
  the interface;
\item width - the physical width of the pWidget to be
  rendered. Applicable to certain pWidgets;
\item funs - functions that will be associated with the given pWidget
  and invoked when a given operation to the pWidget takes place
  (e. g. clicked, get focused ...);
\item preFun - the function defining the operations to be performed on
  the text of the pWidget before rendering the text;
\item postFun - the function defining the operations to be performed
  on the text of the pWdiget upon existing;
\itme notify - a list of functions defning the actions to be performed
  when the value of the pWidget changes.
\end{itemize}

Widget elements text box, list box, and entry box are subjects of
basicPW class. Subclasses of basicPW include:

\begin{verbatim}

   |-------------------|    |-------------------|    |--------------|
   |   selectBox       |    |     Button        |    |    label     |
   |-------------------|    |-------------------|    |--------------|
   | text: string      |    | text: string      |    | text: string |
   | default: string   |    | command: function |    |              |
   | command: function |    |                   |    |              |
   |-------------------|    |-------------------|    |--------------|


\end{verbatim}

Where:

\begin{itemize}
\item text - a character string for the text to be displayed with or
  on the widget element;
\item default - a character string for the name of the pWidget that
  will be the default selected option;
\item command - a function that defines the behavor of the pWidget
  when the widget element corresponding it is clicked.

The following code creates several \em{pWidget} objects of different types:

<<>>=
library(widgetTools)
PWEnv <- new.env(hash = TRUE, parent = parent.frame(1))
label1 <- label(name = "label1", value = "File Name: ", env = PWEnv)
entry1 <- entryBox(name = "entry1", value = "Put me in the first row",
env = PWEnv)
list1 <- listBox(name = "aList", value = "Put me in the second row",
                 env = PWEnv)
browse2Entry1 <- function(){
    temp <- get(name(entry1), env = PWEnv)
    tempValue <- fileBrowser()
    value(temp) <- tempValue
    assign(name(temp), temp)
    temp <- get(name(list1), env = PWEnv)
    value(temp) <- tempValue
    assign(name(temp), temp, env = PWEnv)
}
button1 <- button(name = "button1", text = "Browse",
                          command = browse2Entry1, env = PWEnv)
list1 <- listBox(name = "list1", value = "Put me in the second row",
                 env = PWEnv)
radios1 <- radioButton(name = c("radio1", "radio2", "radio3"), text =
     c("Radio1", "Radio2", "Radio3"), default = "radio1", env = PWEnv)
checks1 <- checkButton(name = c("check11", "check22", "check3"), text =
     c("Check1", "Check2", "Chjeck3"), default = "check1", env = PWEnv)
@

Notice that the name and text variables for radios and checks are
vectors of the same length. That define groups of radio buttons or
check buttons that appear together and share the state in the case of
radio buttons. Variable funs of each pWidget should be a list of functions defining
what to do when the event associated with the function occurs. For
example, the function for variable funs of \em{aButton} defines that
when a single click on \em{aButton} occurs, function \em{fileBrowser}
will be called and the returned value will be used to update the value of
\em{anEntry}. pWidget objects have set and get functions to  access
and modify the variables. For example, we can get and set the value
for the type of a pWidget:

<<>> =
name(label1)
name(label1) <- "YYY"
name(label1)
name(label1) <- "label1"
@

The pWidgets need to be put in a list of lists in such a way the appreance of
each pWidget in the list will determine the layout of the
corresponding tcltk widget element on the interface. The order of
pWidgets in the first level list determines the vertical (row) layout
and the order in the secondary list determines the horizontal
layout. For example, if we want to have the first three \em{pWidget}s
to appear in one row one after the other, the fourth \em{pWidget}
appears in one row below the top row, and the last two \em{pWidget}s
in one row further below, we will need to put them in a list like this:

<<>>=
pWidgets <- list(topRow = list(label1 = label1, entry1 = entry1,
                 button1 = button1), list1 = list1, radios1 =
                 radios1, checks1 = checks1)
pWidgets
@

When we have the layout of \em{pWidget}s figured out, we can proceed
to create a \em{widget} object that will create the actual
interface. A \em{widget} object is defined as following:

\begin{verbatim}

             |-----------------------|
             |         widget        |
             |-----------------------|
             | pWidgets: list        |
             | funs: list            |
             | preFun: function      |
             | postFun: function     |
             |-----------------------|

\end{verbatim}

where

\begin{itemize}
\item pWidgets - a list of lists with each element being a pWidget
  object;
\item funs - a list of functions that will be associated with buttons
  on the interface to be created. The name of a function in the list
  will be the text appears on the button and the function will be
  executed when the button is pressed;
\item preFun - a function that will be executed when the tcltk widget
  is constructed;
\item postFun - a function that will be executed when the tcltk widget
  is destroyed.
\end{itemize}

The following code constructs a \em{widget} object:

<<>>=
widget <- widget(title = "A test widget", pWidgets, funs = list(),
                 preFun = function() print("Hello"),
                 postFun = function() print("Bye"))
@

If we click the browse button, selecte a file through the interface,
and then click finish, the values of the pWidgets corresponding to the
widget elements on the interface will be changed. For example, the
value for \em{list1} will be:

<<>>=
value(pWidgets(widget)[["list1"]])
@

\end{document}



























