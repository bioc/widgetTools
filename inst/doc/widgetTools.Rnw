% \VignetteIndexEntry{widgetTools Introduction}
% \VignetteDepends{widgetTools}
% \VignettePackage{widgetTools}
\documentclass[12pt]{article}
\usepackage{hyperref}
\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in


\begin{document}
\author{Jianhua Zhang}

\title{Building a widget using widgetTools}

\maketitle

\copyright{2002 Bioconductor}

\begin{verbatim}
$Id: widgetTools.Rnw,v 1.3 2002/12/02 14:15:24 jhnzhang Exp $
\end{verbatim}

\tableofcontents

\section{Introduction}

The purpose of widgetTools is to provide the functionalities to allow
users to build funcitonal simple widget. The underlying implementation
of the widget is done by using the R tcltk package but users of
widgetTools do not have to know tcltk command except for some
knowledge of basic geometric management for packing the elements of a
widget.

The design of widgetTools follows the Model-View-Controller pattern
with \em{pWidget} objects as the model, a \em{tkWidget}(s) as the
view, and a \em{updater} as the controller. The interactions between
the model and view follows an observer pattern with a object called
notifier acting as a mediator. Similarly, the interaction between the
view and model also follows a observer pattern with the controller
(\em{updater}) itself acting as a mediator.

Detailed description of \em{pWidget} can be found in
\em{widgetPlans.tex} in the \em{doc} subdirectory of widgetTools and
documantations regarding Model-View-Controller, observer, and mediator
patterns should be available in most designe pattern books. \em{Design
  Patterns} by Gamma et. al. (1997) would be one of them.

\section{Builde a widget}

The first step in building a widget is to crate a tcltk window object
(of tkWidget class) to hold the widget elements (of pWidget class) we
are going to put on (note that a checking was put in to avoid running
the code other than an active consol).

<<>>=
library(widgetTools)
if(interactive()){
    aWidget <- tkWidget(title = "A Test Widget")
}
@

A tkWidget object can hold one to many pWidget objects, which contains
methods and variables described below:

\begin{verbatim}

             |-----------------------|
             |        pWidget        |
             |-----------------------|
             | attach(view, observer)|
             | detach(view, observer)|
             | update(value)         |
             |                       |
             | name: string          |
             | parent: string        |
             | type: string          |
             | test: string          |
             | variable: string      |
             | width: integer        |
             | height: integer       |
             | vSCroll: boolean      |
             | hscroll: boolean      |
             | observer: vector      |
             | preFun: function      |
             | postFun: function     |
             |-----------------------|

\end{verbaeim}

Where

\begin{itermize}

\item name - the name associated with a given pWidget;
\item type - type of a tk widget (e. g. "text" for text box, "list"
  for list box, ...;
\item parent - the window or frame ... where a given pWidget resides;
\item text - the text feature of a pWidget whose role varies depending
  on the type of widget. If pWidget is a text box, text will be shown
  in the text box rendered. If pWidget is a button, text will be the
  letters that appear on the rendered clikable button ...;
\item variable - a variable that will be associated with the given
  pWidget. Most useable for radio buttons or select boxes;
\item width - the physical width of the pWidget to be
  rendered. Applicable to certain pWidgets;
\item height - the physical height of the pWidget to be rendered;
\item vSCroll - set to be TRUE if the pWidget will have a vertical
  scroll bar;
\item hScroll - set to be TRUE if the pWidget will habe a horizontal
  scroll bar;
\item funs - functions that will be associated with the given pWidget
  and invoked when a given operation to the pWidget takes place
  (e. g. clicked, get focused ...);
\item preFun - the function defining the operations to be performed on
  the text of the pWidget before rendering the text;
\item postFun - the function defining the operations to be performed
  on the text of the pWdiget upon existing;

\end{itemize}

pWidgets may be placed on a tkWidget directly or placed as groups of
pWidgets for better presentation. In the latter case, grouped pWidgets
will have to be placed in different frames and the frames are than
placed on to a tkWidget object. Suppose we would like to create a
widget that has a label ("File Name"), an entry box for inputing file
name, and button for browsing files in one row. Below that row, we
want to have a list box in one row, two radio buttons in another row,
and two select boxes in yet another row. To do that we will need to
have four frames for widget elements in each of the four row. Each
frame has the tkWidget object we created previously as the
parent. Note that a frame can also be the parent of other frames and
so on depending on the level of nesting one would like to have. When we
have the frames ready, we can create the widget elements with their
parents being the frames they belong to. The following code creates
the three widget elements in the first row.

<<>>=
frame1 <- createFrame(aWidget)
aLabel <- pWidget(type = "label", parent = "frame1",
text = "File Name: ")
anEntry <- pWidget(type = "entry", parent = "frame2", width = 30, text = "")
aButton <- pWidget(type = "button", parent = "frame3", text =
                   "Browse", width = 12)
@

tkWidget objects have set and get functions to access and modify the
variables. For example, we can get and set the value for the type of a
pWidget:

<<>> =
getType(aLabel)
aLabel <- setType(aLabel, "entry")
getType(aLabel)
aLabel <- setType(aLabel, "label")
@

Now we have three object of the class pWidget with instructions on how
the corresponding tcltk widget element should be constructed. The
follow convert the three objects into tcltk widget elements based on
the definations and then put the tcltk elements in the frame they belong to.

<<>>=
if(interactive()){
    aLabel <- createPWidget(aLabel, frame1)
    anEntry <- createPWidget(anEntry, frame1)
    aButton <- createPWidget(aButton, frame1)
    doPack(getName(aLabel), "left")
    doPack(getName(anEntry), "left")
    doPack(getName(aButton), "left")
    doPack(frame1, "top")
}
@

When a pWidget is created and the corresponding tcltk widget element
is put in place, a "tkwin" object representing the tcltk widget
element is stored as the name of the pWidget.

Now, we continue to build the list box we want and put it below the
first we just built.

<<>> =
frame2 <- createFrame(aWidget)
aList <- pWidget(type = "list", parent = "frame2",
text = "I am in the second row", width = 50, height = 20, vScroll = TRUE,
hScroll = TRUE)
aList <- createPWidget(aList, frame2)
doPack(frame2, "top")
@

A few more variables need to be defined to build radio buttons. One is
the varaible, which is required to be a tclVar object. Radio buttons
in the same group (only one of which can be selected) should have the
same value for their variables. Another is \em(value} that defines who
is the defult (value = 1).

<<>>=
frame3 <- createFrame(aWidget)
radVar <- tclVar(1)
radio1 <- pWidget(type = "radio", parent = "frame3", text = "Selecte Me",
value = 1, variable = radVar)
radio2 <- pWidget(type = "radio", parent = "frame3", text = "How ABout Me",
value = 2, variable = radVar)
radio1 <- createPWidget(radio1, frame3)
radio2 <- createPWidget(radio2, frame3)
doPack(getName(radio1), "left")
doPack(getName(radio2), "left")
doPack(frame3, "top")
@

\end{document}



























