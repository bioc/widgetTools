% \VignetteIndexEntry{widgetTools Introduction}
% \VignetteDepends{widgetTools}
% \VignettePackage{widgetTools}
\documentclass[12pt]{article}
\usepackage{hyperref}
\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in


\begin{document}
\author{Jianhua Zhang}

\title{Building a widget using widgetTools}

\maketitle

\copyright{2002 Bioconductor}

\begin{verbatim}
$Id: widgetTools.Rnw,v 1.6 2002/12/09 19:51:21 jhnzhang Exp $
\end{verbatim}

\tableofcontents

\section{Introduction}

The purpose of widgetTools is to provide the functionalities to allow
users to build funcitonal simple widget. The underlying implementation
of the widget is done by using the R tcltk package but users of
widgetTools do not have to know tcltk command except for some
knowledge of basic geometric management for packing the elements of a
widget.

The design of widgetTools follows the Model-View-Controller pattern
with \em{pWidget} objects being the application data, each of which contains
definitions for a tcltk widget that is going to be created, a
\em{widget} object that contains a list of \em{pWidget}s that will
appera in a tcltk widget that is going to be created and some definiations, a
\em{tkWidget}(s) that provides the interface to create a tcltk widget,
a \em{notifier} that updates the value of tcltk widget element when
needed, and a \em{updater} object that updates the values of pWidgts
when needed. \em{pWidget} and \em{widget} are the model, tkWidget is
the view, and update is the controller component of the MVC
pattern. The interactions between the model and view follows an
observer pattern with a \em{notifier} acting as a mediator. Similarly,
the interactions between the view and and model also follows a
observer pattern with the controller (\em{updater}) itself acting as a
mediator.

Detailed description of \em{pWidget} can be found in
\em{widgetPlans.tex} in the \em{doc} subdirectory of widgetTools and
documantations regarding Model-View-Controller, observer, and mediator
patterns should be available in most designe pattern books. \em{Design
  Patterns} by Gamma et. al. (1997) would be one of them.

The system is designed in such a way that users only have to deal with
\em{pWidget} and \em{widget} objects. The other objects will be
created and managed by the system.

\section{Builde a widget}

The first step involved in building a widget is to crate a list of
\em{pWidgets} that defines the interface of the tcltk widget that is
going to be created. A pWidget is a S4 class with the features described in
the class diargam shown below:

\begin{verbatim}

             |-----------------------|
             |        pWidget        |
             |-----------------------|
             | name: string          |
             | winid: tkwin          |
             | type: string          |
             | text: string          |
             | value: string         |
             | variable: string      |
             | width: integer        |
             | height: integer       |
             | vSCroll: boolean      |
             | hscroll: boolean      |
             | observers: list       |
             | funs: list            |
             | preFun: function      |
             | postFun: function     |
             |-----------------------|

\end{verbatim}

Where

\begin{itemize}

\item name - the name associated with a given pWidget;
\item winid - a tkwin object generated by tcltk when a pWidget object
  is used to create a tcltk widget element. The value will be assined
  by the system at run time;
\item type - type of a tk widget (e. g. "text" for text box, "list"
  for list box, ...;
\item text - the text feature of a pWidget whose role varies depending
  on the type of widget. If pWidget is a text box, text will be shown
  in the text box rendered. If pWidget is a button, text will be the
  letters that appear on the rendered clikable button ...;
\item value: a character string used to strore information that will
  be displayed on the interface or update using values obtained from
  the interface;
\item variable - a variable that will be associated with the given
  pWidget. Most useable for radio buttons or select boxes;
\item width - the physical width of the pWidget to be
  rendered. Applicable to certain pWidgets;
\item height - the physical height of the pWidget to be rendered;
\item vSCroll - set to be TRUE if the pWidget will have a vertical
  scroll bar;
\item hScroll - set to be TRUE if the pWidget will habe a horizontal
  scroll bar;
\item funs - functions that will be associated with the given pWidget
  and invoked when a given operation to the pWidget takes place
  (e. g. clicked, get focused ...);
\item preFun - the function defining the operations to be performed on
  the text of the pWidget before rendering the text;
\item postFun - the function defining the operations to be performed
  on the text of the pWdiget upon existing;

\end{itemize}

The following code creates several \em{pWidget} objects:

<<>>=
library(widgetTools)
aLabel <- pWidget(name = "aLabel", type = "label", text = "File Name: ",
width = 0)
anEntry <- pWidget(name = "anEntry", type = "entry", width = 50,
text = "I am in the first row")
aButton <- pWidget(name = "aButton", type = "button", text = "Browse",
                   width = 12, observers = list(anEntry),
                   funs = list(command = fileBrowser))
aList <- pWidget(name = "aList", type = "list",
text = "I am in the second row", width = 50, height = 20, vScroll = TRUE,
hScroll = TRUE)
radVar <- tclVar(1)
radio1 <- pWidget(name = "radio1", type = "radio", text = "SelecteMe",
value = 1, variable = radVar)
radio2 <- pWidget(name = "radio2", type = "radio", text = "How ABout Me",
value = 2, variable = radVar)
@

The \em{name} variable of each pWidget object should always been
assinged the same character string as the name of the pWidget object
(e.g. "aButton" for pWidget object \em{aButton}). Variable funs of
each pWidget should be a list of functions defining what to do when
the event associated with the function occurs. For example, the
function for variable funs of \em{aButton} defines that when a single
click on \em{aButton} occurs, function \em{fileBrowser} will be called
and the returned value will be used to update the value of
\em{anEntry}. pWidget objects have set and get functions to  access
and modify the variables. For example, we can get and set the value
for the type of a pWidget:

<<>> =
getName(aLabel)
name(aLabel) <- "YYY"
getName(aLabel)
name(aLabel) <- "aLabel"
@

The pWidgets need to be put in a list of lists in such a way the appreance of
each pWidget in the list will determine the layout of the
corresponding tcltk widget element on the interface. The order of
pWidgets in the first level list determines the vertical (row) layout
and the order in the secondary list determines the horizontal
layout. For example, if we want to have the first three \em{pWidget}s
to appear in one row one after the other, the fourth \em{pWidget}
appears in one row below the top row, and the last two \em{pWidget}s
in one row further below, we will need to put them in a list like this:

<<>>=
pWidgets <- list(topRow = list(aLabel = aLabel, anEntry = anEntry,
                 aButton = aButton), aList = aList, bottomRow =
                 list(radio1 = radio1, radio2 = radio2))
pWidgets
@

When we have the layout of \em{pWidget}s figured out, we can proceed
to create a \em{widget} object that will create the actual
interface. A \em{widget} object is defined as following:

\begin{verbatim}

             |-----------------------|
             |         widget        |
             |-----------------------|
             | pWidgets: list        |
             | funs: list            |
             | preFun: function      |
             | postFun: function     |
             |-----------------------|

\end{verbatim}

where

\begin{itemize}
\item pWidgets - a list of lists with each element being a pWidget
  object;
\item funs - a list of functions that will be associated with buttons
  on the interface of the tcltk widget to be created. The name of the
  function will be the text appears on the button and the function
  will be executed when the button is pressed;
\item preFun - a function that will be executed when the tcltk widget
  is constructed;
\item postFun - a function that will be executed when the tcltk widget
  is destroyed.
\end{itemize}

The following code constructs a \em{widget} object:

<<>>=
widget <- widget(title = "A test widget", pWidgets, funs = list(),
                 preFun = function() "Hello", postFun = function() "Bye")
@

 \em{name} variable of each pWidget object should always been
assinged the same character string as the name of the pWidget object
(e.g. "aButton" for pWidget object \em{aButton}). Variable funs of
each pWidget should be a list of functions defining what to do when
the event associated with the function occurs. For example, the
function for variable funs of \em{aButton} defines that when a single
click on \em{aButton} occurs, function fileBrowser will be called and
returned value will be passed to updatePWidget to update the value of
pWidget \em{aButton}. pWidget objects have set and get functions to
access and modify the variables. For example, we can get and set the
value for the type of a pWidget:

<<>> =
getName(aLabel)
name(aLabel) <- "YYY"
getName(aLabel)
name(aLabel) <- "aLabel"
@

Now we have three objects of the class pWidget with instructions on how
the corresponding tcltk widget element should be constructed. The
follow convert the three objects into tcltk widget elements based on
the definations and then put the tcltk elements in the frame they belong to.

<<>>=
if(interactive()){
    aLabel <- createPWidget(aLabel, frame1)
    anEntry <- createPWidget(anEntry, frame1)
    aButton <- createPWidget(aButton, frame1)
    doPack(getWinid(aLabel), "left")
    doPack(getWinid(anEntry), "left")
    doPack(getWinid(aButton), "left")
    doPack(frame1, "top")
}
@

When a pWidget is created and the corresponding tcltk widget element
is put in place, a "tkwin" object representing the tcltk widget
element is stored as the winid of the pWidget. Variable winid can be
used later to access the tcltk widget object on the interface.

Now we have a simple interface that does something. If we click the
browse button and select a file name from the browser, the value of
\em{aButton} will be assigned the full path to the file we just
selected as instructed by the function we put as the funs variable of
\em{aButton}.

<<>>=
getValue(aButton)
@

However, what we really want is also to have the file name shown in
the entry box for file name on the interface. To do so, we need to
register \em{anEntry} as an observer of \em{aBuuton} so that each time
when the value of \em{aButton} changes the entry box corresponding to
\em{anEntry} will be notified to make the corresponding changes.

<<>>=
notifier <- register(notifier, getName(aButton), anEntry)
getSubNObse(notifier)
@

Now, when we click the browse button and select a file again, the selected
file will be shown in the entry box and the value of the pWidget
corresponding to the entry box will be updated as well.

<<>>=
getValue(anEntry)
@

Now, we continue to build the list box we want and put it below the
first we just built.

<<>> =
frame2 <- createFrame(aWidget)
aList <- pWidget(name = "aList", type = "list", text = "I am in the second row", width = 50, height = 20, vScroll = TRUE,
hScroll = TRUE)
aList <- createPWidget(aList, frame2)
doPack(frame2, "top")
@

A few more variables need to be defined to build radio buttons. One is
the varaible, which is required to be a tclVar object. Radio buttons
in the same group (only one of which can be selected) should have the
same value for their variables. Another is \em(value} that defines who
is the defult (value = 1).

<<>>=
frame3 <- createFrame(aWidget)
radVar <- tclVar(1)
radio1 <- pWidget(name = "radio1", type = "radio", parent = "frame3", text = "Selecte Me",
value = 1, variable = radVar)
radio2 <- pWidget(name = "radio2", type = "radio", parent = "frame3", text = "How ABout Me",
value = 2, variable = radVar)
radio1 <- createPWidget(radio1, frame3)
radio2 <- createPWidget(radio2, frame3)
doPack(getWinid(radio1), "left")
doPack(getWinid(radio2), "left")
doPack(frame3, "top")
@

\end{document}



























